<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Sakk</title>
<style>
:root {
--cell: min(9vh, 9vw);
--frame: #1a0a00;
--sq-light: #fff5e6;
--sq-dark: #ff6b35;
--accent: #00e5cc;
--bg: #0d0500;
--text: #00e5cc;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: Arial, sans-serif; background: var(--bg); color: var(--text); display: flex; flex-direction: column; align-items: center; padding: 20px; min-height: 100vh; }
#status { font-size: 20px; font-weight: bold; margin-bottom: 10px; padding: 10px 20px; background: var(--text); color: var(--bg); border-radius: 20px; box-shadow: 0 0 20px rgba(255,102,0,0.6); }
.controls { margin-bottom: 15px; }
button { background: var(--accent); color: var(--bg); border: none; padding: 10px 20px; margin: 0 5px; border-radius: 20px; cursor: pointer; font-weight: bold; }
button:hover { opacity: 0.9; }
.board-wrap { background: var(--frame); padding: 15px; border-radius: 10px; box-shadow: 0 0 30px rgba(255,102,0,0.5), 0 10px 30px rgba(0,0,0,0.8); }
#board { display: grid; grid-template-columns: repeat(8, var(--cell)); grid-template-rows: repeat(8, var(--cell)); border: 2px solid #3a1f0a; }
.sq { width: var(--cell); height: var(--cell); display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: calc(var(--cell) * 0.7); position: relative; text-shadow: 0 0 5px rgba(0,0,0,1), 2px 2px 3px rgba(0,0,0,0.9); filter: drop-shadow(0 0 2px rgba(255,255,255,0.3)); }
.light { background: var(--sq-light); }
.dark { background: var(--sq-dark); }
.sel { outline: 3px solid var(--accent); outline-offset: -3px; }
.hint::after { content: ''; position: absolute; width: 30%; height: 30%; background: rgba(34,197,94,0.7); border-radius: 50%; }
.capture::after { content: ''; position: absolute; inset: 5px; border: 3px solid rgba(34,197,94,0.8); border-radius: 5px; }
.check { box-shadow: inset 0 0 0 4px #ef4444; }
.last { background-color: rgba(255,204,0,0.4) !important; }
#promo { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); align-items: center; justify-content: center; z-index: 100; }
.promo-box { background: var(--text); color: var(--bg); padding: 20px; border-radius: 10px; display: flex; gap: 10px; }
.promo-box button { font-size: 30px; }
</style>
</head>
<body>
<div id="status">White</div>
<div class="controls">
<button onclick="newGame()">New Game</button>
<button onclick="flip()">Flip Board</button>
</div>
<div class="board-wrap">
<div id="board"></div>
</div>
<div id="promo">
<div class="promo-box">
<span>Promote to:</span>
<button onclick="promote('q')">♕</button>
<button onclick="promote('r')">♖</button>
<button onclick="promote('b')">♗</button>
<button onclick="promote('n')">♘</button>
</div>
</div>
<script>
const pieces = {w:{p:'♙',r:'♖',n:'♘',b:'♗',q:'♕',k:'♔'},b:{p:'♟',r:'♜',n:'♞',b:'♝',q:'♛',k:'♚'}};
let b = Array(8).fill().map(()=>Array(8).fill(null));
let turn = 'w', sel = null, moves = [], over = false, flipped = false, last = null;
let castle = {wk:1,wq:1,bk:1,bq:1}, ep = null, pending = null;

// JAVÍTOTT INIT FÜGGVÉNY: Kap egy opcionális shouldDraw paramétert.
function init(shouldDraw = true) {
const rows = ['rnbqkbnr','pppppppp','........','........','........','........','PPPPPPPP','RNBQKBNR'];
for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
const ch = rows[r][c];
if(ch !== '.') b[r][c] = {c: ch===ch.toUpperCase()?'w':'b', t: ch.toLowerCase()};
}
if (shouldDraw) {
    draw();
}
}

function draw() {
const bd = document.getElementById('board');
bd.innerHTML = '';
const rows = flipped ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
const cols = flipped ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
for(let r of rows) for(let c of cols) {
const sq = document.createElement('div');
sq.className = 'sq ' + ((r+c)%2?'dark':'light');
sq.onclick = ()=>click(r,c);
const p = b[r][c];
if(p) {
sq.textContent = pieces[p.c][p.t];
sq.style.color = p.c==='w' ? '#ffffff' : '#ff6600';
}
if(sel && sel.r===r && sel.c===c) sq.classList.add('sel');
if(last && ((last.fr===r&&last.fc===c)||(last.tr===r&&last.tc===c))) sq.classList.add('last');
const m = moves.find(x=>x.tr===r&&x.tc===c);
if(m) sq.classList.add(b[r][c]?'capture':'hint');
const k = findKing(turn);
if(k && k.r===r && k.c===c && inCheck(turn)) sq.classList.add('check');
bd.appendChild(sq);
}
document.getElementById('status').textContent = over ? over : (turn==='w'?'White':'Black');
}

function click(r,c) {
if(over) return;
const m = moves.find(x=>x.tr===r&&x.tc===c);
if(sel && m) { doMove(m); return; }
const p = b[r][c];
if(p && p.c===turn) { sel={r,c}; moves=getLegal(r,c); } else { sel=null; moves=[]; }
draw();
}

function doMove(m) {
const p = b[m.fr][m.fc];
if(p.t==='p' && (m.tr===0||m.tr===7) && !m.pr) { pending=m; document.getElementById('promo').style.display='flex'; return; }
applyMove(m);
}

function promote(t) {
if(pending) { pending.pr=t; document.getElementById('promo').style.display='none'; applyMove(pending); pending=null; }
}

function applyMove(m) {
const p = b[m.fr][m.fc];
if(m.enp) b[m.tr+(p.c==='w'?1:-1)][m.tc] = null;
if(m.cas) {
const row=m.fr;
if(m.cas==='K') { b[row][5]=b[row][7]; b[row][7]=null; }
else { b[row][3]=b[row][0]; b[row][0]=null; }
}
b[m.tr][m.tc] = {c:p.c, t:m.pr||p.t};
b[m.fr][m.fc] = null;
if(p.t==='k') { if(p.c==='w'){castle.wk=0;castle.wq=0;}else{castle.bk=0;castle.bq=0;} }
if(p.t==='r') {
if(p.c==='w'&&m.fr===7) { if(m.fc===0)castle.wq=0; if(m.fc===7)castle.wk=0; }
if(p.c==='b'&&m.fr===0) { if(m.fc===0)castle.bq=0; if(m.fc===7)castle.bk=0; }
}
ep = null;
if(p.t==='p' && Math.abs(m.tr-m.fr)===2) ep = {r:(m.fr+m.tr)/2, c:m.fc};
turn = turn==='w'?'b':'w';
last = {fr:m.fr,fc:m.fc,tr:m.tr,tc:m.tc};
sel=null; moves=[];
checkEnd();
saveGame();
draw();
}

function getLegal(r,c) {
const p = b[r][c]; if(!p) return [];
let ms = getPseudo(r,c,p);
return ms.filter(m=>!checksKing(m,p.c));
}

function getPseudo(r,c,p) {
const ms=[], d=p.c==='w'?-1:1;
const add=(tr,tc,x={})=>{ if(tr>=0&&tr<8&&tc>=0&&tc<8){const t=b[tr][tc]; if(!t||t.c!==p.c)ms.push({fr:r,fc:c,tr,tc,...x});} };
if(p.t==='p') {
if(!b[r+d][c]) add(r+d,c);
const sr=p.c==='w'?6:1; if(r===sr&&!b[r+d][c]&&!b[r+2*d][c]) add(r+2*d,c);
[-1,1].forEach(dc=>{ const t=b[r+d][c+dc]; if(t&&t.c!==p.c) add(r+d,c+dc); });
if(ep&&ep.r===r+d&&Math.abs(ep.c-c)===1) ms.push({fr:r,fc:c,tr:ep.r,tc:ep.c,enp:1});
}
if(p.t==='n') [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc])=>add(r+dr,c+dc));
if(p.t==='b'||p.t==='q') [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>{ let rr=r+dr,cc=c+dc; while(rr>=0&&rr<8&&cc>=0&&cc<8){const t=b[rr][cc];if(!t)ms.push({fr:r,fc:c,tr:rr,tc:cc});else{if(t.c!==p.c)ms.push({fr:r,fc:c,tr:rr,tc:cc});break;}rr+=dr;cc+=dc;} });
if(p.t==='r'||p.t==='q') [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{ let rr=r+dr,cc=c+dc; while(rr>=0&&rr<8&&cc>=0&&cc<8){const t=b[rr][cc];if(!t)ms.push({fr:r,fc:c,tr:rr,tc:cc});else{if(t.c!==p.c)ms.push({fr:r,fc:c,tr:rr,tc:cc});break;}rr+=dr;cc+=dc;} });
if(p.t==='k') {
for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++)if(dr||dc)add(r+dr,c+dc);
if(!inCheck(p.c)) {
if(p.c==='w') {
if(castle.wk&&!b[7][5]&&!b[7][6]&&!attacked(7,5,'w')&&!attacked(7,6,'w')) ms.push({fr:r,fc:c,tr:7,tc:6,cas:'K'});
if(castle.wq&&!b[7][1]&&!b[7][2]&&!b[7][3]&&!attacked(7,3,'w')&&!attacked(7,2,'w')) ms.push({fr:r,fc:c,tr:7,tc:2,cas:'Q'});
} else {
if(castle.bk&&!b[0][5]&&!b[0][6]&&!attacked(0,5,'b')&&!attacked(0,6,'b')) ms.push({fr:r,fc:c,tr:0,tc:6,cas:'K'});
if(castle.bq&&!b[0][1]&&!b[0][2]&&!b[0][3]&&!attacked(0,3,'b')&&!attacked(0,2,'b')) ms.push({fr:r,fc:c,tr:0,tc:2,cas:'Q'});
}
}
}
return ms;
}

function checksKing(m,col) {
const tmp = b.map(r=>r.map(p=>p?{...p}:null));
const p = tmp[m.fr][m.fc];
if(m.enp) tmp[m.tr+(p.c==='w'?1:-1)][m.tc]=null;
if(m.cas) { const row=m.fr; if(m.cas==='K'){tmp[row][5]=tmp[row][7];tmp[row][7]=null;}else{tmp[row][3]=tmp[row][0];tmp[row][0]=null;} }
tmp[m.tr][m.tc] = {c:p.c,t:m.pr||p.t};
tmp[m.fr][m.fc] = null;
let kr,kc;
for(let r=0;r<8;r++)for(let c=0;c<8;c++)if(tmp[r][c]&&tmp[r][c].t==='k'&&tmp[r][c].c===col){kr=r;kc=c;}
return attacked(kr,kc,col,tmp);
}

function findKing(col) {
for(let r=0;r<8;r++)for(let c=0;c<8;c++)if(b[r][c]&&b[r][c].t==='k'&&b[r][c].c===col)return{r,c};
return null;
}

function inCheck(col) {
const k=findKing(col); return k&&attacked(k.r,k.c,col);
}

function attacked(r,c,col,bd=b) {
const e=col==='w'?'b':'w';
const pr=e==='w'?r-1:r+1;
if(pr>=0&&pr<8) for(let dc of[-1,1]){ const cc=c+dc; if(cc>=0&&cc<8&&bd[pr][cc]&&bd[pr][cc].c===e&&bd[pr][cc].t==='p')return 1; }
for(let[dr,dc]of[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]){ const rr=r+dr,cc=c+dc; if(rr>=0&&rr<8&&cc>=0&&cc<8&&bd[rr][cc]&&bd[rr][cc].c===e&&bd[rr][cc].t==='n')return 1; }
for(let[dr,dc]of[[1,1],[1,-1],[-1,1],[-1,-1]]){ let rr=r+dr,cc=c+dc; while(rr>=0&&rr<8&&cc>=0&&cc<8){const t=bd[rr][cc];if(t){if(t.c===e&&(t.t==='b'||t.t==='q'))return 1;break;}rr+=dr;cc+=dc;} }
for(let[dr,dc]of[[1,0],[-1,0],[0,1],[0,-1]]){ let rr=r+dr,cc=c+dc; while(rr>=0&&rr<8&&cc>=0&&cc<8){const t=bd[rr][cc];if(t){if(t.c===e&&(t.t==='r'||t.t==='q'))return 1;break;}rr+=dr;cc+=dc;} }
for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++)if(dr||dc){ const rr=r+dr,cc=c+dc; if(rr>=0&&rr<8&&cc>=0&&cc<8&&bd[rr][cc]&&bd[rr][cc].c===e&&bd[rr][cc].t==='k')return 1; }
return 0;
}

function checkEnd() {
let all=[];
for(let r=0;r<8;r++)for(let c=0;c<8;c++)if(b[r][c]&&b[r][c].c===turn)all.push(...getLegal(r,c));
if(!all.length) over = inCheck(turn) ? ((turn==='w'?'Black':'White')+' wins!') : 'Stalemate - Draw';
}

function newGame() { b=Array(8).fill().map(()=>Array(8).fill(null)); turn='w'; sel=null; moves=[]; over=false; last=null; castle={wk:1,wq:1,bk:1,bq:1}; ep=null; init(); saveGame(); }
function flip() { flipped=!flipped; draw(); }

function saveGame() {
try {
const data = {b,turn,castle,ep,last,over,flipped};
localStorage.setItem('chess_save', JSON.stringify(data));
} catch(e) {}
}

// JAVÍTOTT LOADGAME FÜGGVÉNY: Csak akkor hívja az init()-et, ha nincs mentett játékállás.
function loadGame() {
try {
const saved = localStorage.getItem('chess_save');
if(saved) {
const data = JSON.parse(saved);
b = data.b || b;
turn = data.turn || turn;
castle = data.castle || castle;
ep = data.ep || ep;
last = data.last || last;
over = data.over || over;
flipped = data.flipped || flipped;
} else {
    // Ha nincs mentett játék, inicializáld a kezdőállást
    init(false); 
}
} catch(e) {
    // Hiba esetén is inicializáld, hogy a játék használható legyen
    init(false);
}
}

loadGame();
// init(); // AZ init() HÍVÁS INNEN TÖRÖLVE, HOGY NE ÍRJA FELÜL A BETÖLTÖTT ÁLLAPOTOT.
draw(); // A betöltött vagy inicializált állapot kirajzolása.
</script>
</body>
</html>