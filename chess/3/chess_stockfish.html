<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sakk — Stockfish integrálva (GitHub Pages ready)</title>
<style>
:root{--cell:min(9vh,9vw);--frame:#1a0000;--sq-light:#ffffff;--sq-dark:#330000;--accent:#ff6600;--bg:#0d0000;--text:#ff6600}
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:var(--text);display:flex;flex-direction:column;align-items:center;padding:20px;min-height:100vh}
#status{font-size:20px;font-weight:700;margin-bottom:10px;padding:10px 20px;background:var(--text);color:var(--bg);border-radius:20px;box-shadow:0 0 20px rgba(255,102,0,0.6)}
.controls{margin-bottom:15px}
button{background:var(--accent);color:var(--bg);border:none;padding:8px 14px;margin:0 5px;border-radius:16px;cursor:pointer;font-weight:700}
button:hover{opacity:.9}
.board-wrap{background:var(--frame);padding:12px;border-radius:10px;box-shadow:0 0 30px rgba(255,102,0,0.5),0 10px 30px rgba(0,0,0,.8)}
#board{display:grid;grid-template-columns:repeat(8,var(--cell));grid-template-rows:repeat(8,var(--cell));border:2px solid #3a1f0a}
.sq{width:var(--cell);height:var(--cell);display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:calc(var(--cell)*0.7);position:relative;text-shadow:0 0 5px rgba(0,0,0,1),2px 2px 3px rgba(0,0,0,.9);filter:drop-shadow(0 0 2px rgba(255,255,255,0.3))}
.light{background:var(--sq-light)}
.dark{background:var(--sq-dark)}
.sel{outline:3px solid var(--accent);outline-offset:-3px}
.hint::after{content:'';position:absolute;width:28%;height:28%;background:rgba(34,197,94,0.7);border-radius:50%}
.capture::after{content:'';position:absolute;inset:5px;border:3px solid rgba(34,197,94,0.8);border-radius:5px}
.check{box-shadow:inset 0 0 0 4px #ef4444}
.last{background-color:rgba(255,204,0,0.35)!important}
#promo{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.7);align-items:center;justify-content:center;z-index:100}
.promo-box{background:var(--text);color:var(--bg);padding:20px;border-radius:10px;display:flex;gap:10px}
.promo-box button{font-size:30px}
.engine-indicator{display:inline-block;margin-left:8px;font-size:14px;opacity:.9}
</style>
</head>
<body>
<div id="status">White</div>
<div class="controls">
  <button onclick="newGame()">New Game</button>
  <button onclick="flip()">Flip Board</button>
  <button id="vsEngineBtn" onclick="toggleEngine()">Play vs Engine</button>
  <span class="engine-indicator" id="engineInfo">Engine: off</span>
</div>

<div class="board-wrap"><div id="board"></div></div>

<div id="promo">
  <div class="promo-box">
    <span>Promote to:</span>
    <button onclick="promote('q')">♕</button>
    <button onclick="promote('r')">♖</button>
    <button onclick="promote('b')">♗</button>
    <button onclick="promote('n')">♘</button>
  </div>
</div>

<script>
/* -----------------------
   Config / engine CDN
   -----------------------
   Stockfish WASM (worker) lesz betöltve CDN-ről,
   amely GitHub Pages alatt is működik (static host).
   Forrás: jsDelivr / stockfish.wasm build. :contentReference[oaicite:1]{index=1}
*/
const STOCKFISH_WORKER_URL = 'https://cdn.jsdelivr.net/npm/stockfish.wasm@0.10.0/stockfish.worker.js';

/* -----------------------
   Chess UI + logic (a te eredeti kódod alapján)
   ----------------------- */
const pieces = {w:{p:'♙',r:'♖',n:'♘',b:'♗',q:'♕',k:'♔'},b:{p:'♟',r:'♜',n:'♞',b:'♝',q:'♛',k:'♚'}};
let b = Array(8).fill().map(()=>Array(8).fill(null));
let turn = 'w', sel = null, moves = [], over = false, flipped = false, last = null;
let castle = {wk:1,wq:1,bk:1,bq:1}, ep = null, pending = null;

function init(shouldDraw = true) {
  const rows = ['rnbqkbnr','pppppppp','........','........','........','........','PPPPPPPP','RNBQKBNR'];
  for(let r=0;r<8;r++) for(let c=0;c<8;c++) {
    const ch = rows[r][c];
    if(ch !== '.') b[r][c] = {c: ch===ch.toUpperCase()?'w':'b', t: ch.toLowerCase()};
    else b[r][c] = null;
  }
  if(shouldDraw) draw();
}

function draw() {
  const bd = document.getElementById('board');
  bd.innerHTML = '';
  const rows = flipped ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
  const cols = flipped ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
  for(let r of rows) for(let c of cols) {
    const sq = document.createElement('div');
    sq.className = 'sq ' + ((r+c)%2?'dark':'light');
    sq.onclick = ()=>click(r,c);
    const p = b[r][c];
    if(p) { sq.textContent = pieces[p.c][p.t]; sq.style.color = p.c==='w' ? '#ffffff' : '#ff6600'; }
    if(sel && sel.r===r && sel.c===c) sq.classList.add('sel');
    if(last && ((last.fr===r&&last.fc===c)||(last.tr===r&&last.tc===c))) sq.classList.add('last');
    const m = moves.find(x=>x.tr===r&&x.tc===c);
    if(m) sq.classList.add(b[r][c]?'capture':'hint');
    const k = findKing(turn);
    if(k && k.r===r && k.c===c && inCheck(turn)) sq.classList.add('check');
    bd.appendChild(sq);
  }
  document.getElementById('status').textContent = over ? over : (turn==='w'?'White':'Black');
}

/* click / move apply */
function click(r,c) {
  if(over) return;
  const m = moves.find(x=>x.tr===r&&x.tc===c);
  if(sel && m) { doMove(m); return; }
  const p = b[r][c];
  if(p && p.c===turn) { sel={r,c}; moves=getLegal(r,c); } else { sel=null; moves=[]; }
  draw();
}

function doMove(m) {
  const p = b[m.fr][m.fc];
  if(p.t==='p' && (m.tr===0||m.tr===7) && !m.pr) { pending=m; document.getElementById('promo').style.display='flex'; return; }
  applyMove(m);
}

function promote(t) {
  if(pending) { pending.pr=t; document.getElementById('promo').style.display='none'; applyMove(pending); pending=null; }
}

function applyMove(m) {
  const p = b[m.fr][m.fc];
  if(m.enp) b[m.tr+(p.c==='w'?1:-1)][m.tc] = null;
  if(m.cas) {
    const row=m.fr;
    if(m.cas==='K') { b[row][5]=b[row][7]; b[row][7]=null; }
    else { b[row][3]=b[row][0]; b[row][0]=null; }
  }
  b[m.tr][m.tc] = {c:p.c, t:m.pr||p.t};
  b[m.fr][m.fc] = null;
  if(p.t==='k') { if(p.c==='w'){castle.wk=0;castle.wq=0;}else{castle.bk=0;castle.bq=0;} }
  if(p.t==='r') {
    if(p.c==='w'&&m.fr===7) { if(m.fc===0)castle.wq=0; if(m.fc===7)castle.wk=0; }
    if(p.c==='b'&&m.fr===0) { if(m.fc===0)castle.bq=0; if(m.fc===7)castle.bk=0; }
  }
  ep = null;
  if(p.t==='p' && Math.abs(m.tr-m.fr)===2) ep = {r:(m.fr+m.tr)/2, c:m.fc};
  turn = turn==='w'?'b':'w';
  last = {fr:m.fr,fc:m.fc,tr:m.tr,tc:m.tc};
  sel=null; moves=[];
  checkEnd();
  saveGame();
  draw();

  // ha engine be van kapcsolva és most az engine következik => nála a lépés
  if(engineOn && turn === engineColor) {
    setTimeout(()=>engineMakeMove(), 50);
  }
}

function getLegal(r,c) {
  const p = b[r][c]; if(!p) return [];
  let ms = getPseudo(r,c,p);
  return ms.filter(m=>!checksKing(m,p.c));
}

/* PSEUDO + pawn capture fix: gyalog ne üsse le a királyt */
function getPseudo(r,c,p) {
  const ms=[], d=p.c==='w'?-1:1;
  const add=(tr,tc,x={})=>{ if(tr>=0&&tr<8&&tc>=0&&tc<8){const t=b[tr][tc]; if(!t||t.c!==p.c)ms.push({fr:r,fc:c,tr,tc,...x});} };
  if(p.t==='p') {
    if(!b[r+d][c]) add(r+d,c);
    const sr=p.c==='w'?6:1; if(r===sr&&!b[r+d][c]&&!b[r+2*d][c]) add(r+2*d,c);
    [-1,1].forEach(dc=>{
      const t=b[r+d]?.[c+dc];
      if(t && t.c!==p.c && t.t!=='k') add(r+d,c+dc); // itt: ne üsse a királyt
    });
    if(ep&&ep.r===r+d&&Math.abs(ep.c-c)===1) ms.push({fr:r,fc:c,tr:ep.r,tc:ep.c,enp:1});
  }
  if(p.t==='n') [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,dc])=>add(r+dr,c+dc));
  if(p.t==='b'||p.t==='q') [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>{ let rr=r+dr,cc=c+dc; while(rr>=0&&rr<8&&cc>=0&&cc<8){const t=b[rr][cc];if(!t)ms.push({fr:r,fc:c,tr:rr,tc:cc});else{if(t.c!==p.c)ms.push({fr:r,fc:c,tr:rr,tc:cc});break;}rr+=dr;cc+=dc;} });
  if(p.t==='r'||p.t==='q') [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{ let rr=r+dr,cc=c+dc; while(rr>=0&&rr<8&&cc>=0&&cc<8){const t=b[rr][cc];if(!t)ms.push({fr:r,fc:c,tr:rr,tc:cc});else{if(t.c!==p.c)ms.push({fr:r,fc:c,tr:rr,tc:cc});break;}rr+=dr;cc+=dc;} });
  if(p.t==='k') {
    for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++)if(dr||dc)add(r+dr,c+dc);
    if(!inCheck(p.c)) {
      if(p.c==='w') {
        if(castle.wk&&!b[7][5]&&!b[7][6]&&!attacked(7,5,'w')&&!attacked(7,6,'w')) ms.push({fr:r,fc:c,tr:7,tc:6,cas:'K'});
        if(castle.wq&&!b[7][1]&&!b[7][2]&&!b[7][3]&&!attacked(7,3,'w')&&!attacked(7,2,'w')) ms.push({fr:r,fc:c,tr:7,tc:2,cas:'Q'});
      } else {
        if(castle.bk&&!b[0][5]&&!b[0][6]&&!attacked(0,5,'b')&&!attacked(0,6,'b')) ms.push({fr:r,fc:c,tr:0,tc:6,cas:'K'});
        if(castle.bq&&!b[0][1]&&!b[0][2]&&!b[0][3]&&!attacked(0,3,'b')&&!attacked(0,2,'b')) ms.push({fr:r,fc:c,tr:0,tc:2,cas:'Q'});
      }
    }
  }
  return ms;
}

/* checksKing / inCheck / attacked  -- javított pawn irány ellenőrzéssel */
function checksKing(m,col) {
  const tmp = b.map(r=>r.map(p=>p?{...p}:null));
  const p = tmp[m.fr][m.fc];
  if(m.enp) tmp[m.tr+(p.c==='w'?1:-1)][m.tc]=null;
  if(m.cas) { const row=m.fr; if(m.cas==='K'){tmp[row][5]=tmp[row][7];tmp[row][7]=null;}else{tmp[row][3]=tmp[row][0];tmp[row][0]=null;} }
  tmp[m.tr][m.tc] = {c:p.c,t:m.pr||p.t};
  tmp[m.fr][m.fc] = null;
  let kr,kc;
  for(let r=0;r<8;r++)for(let c=0;c<8;c++)if(tmp[r][c]&&tmp[r][c].t==='k'&&tmp[r][c].c===col){kr=r;kc=c;}
  return attacked(kr,kc,col,tmp);
}

function findKing(col) {
  for(let r=0;r<8;r++)for(let c=0;c<8;c++)if(b[r][c]&&b[r][c].t==='k'&&b[r][c].c===col)return{r,c};
  return null;
}

function inCheck(col) {
  const k=findKing(col); return k&&attacked(k.r,k.c,col);
}

function attacked(r,c,col,bd=b) {
  const e=col==='w'?'b':'w';
  // javítva: ha az ellenfél fehér, annak gyalogjai r-1 helyett r+1 (fentről nézve)
  const pr = e==='w' ? r+1 : r-1;
  if(pr>=0&&pr<8) for(let dc of[-1,1]){ const cc=c+dc; if(cc>=0&&cc<8&&bd[pr][cc]&&bd[pr][cc].c===e&&bd[pr][cc].t==='p')return 1; }
  for(let[dr,dc]of[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]){ const rr=r+dr,cc=c+dc; if(rr>=0&&rr<8&&cc>=0&&cc<8&&bd[rr][cc]&&bd[rr][cc].c===e&&bd[rr][cc].t==='n')return 1; }
  for(let[dr,dc]of[[1,1],[1,-1],[-1,1],[-1,-1]]){ let rr=r+dr,cc=c+dc; while(rr>=0&&rr<8&&cc>=0&&cc<8){const t=bd[rr][cc];if(t){if(t.c===e&&(t.t==='b'||t.t==='q'))return 1;break;}rr+=dr;cc+=dc;} }
  for(let[dr,dc]of[[1,0],[-1,0],[0,1],[0,-1]]){ let rr=r+dr,cc=c+dc; while(rr>=0&&rr<8&&cc>=0&&cc<8){const t=bd[rr][cc];if(t){if(t.c===e&&(t.t==='r'||t.t==='q'))return 1;break;}rr+=dr;cc+=dc;} }
  for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++)if(dr||dc){ const rr=r+dr,cc=c+dc; if(rr>=0&&rr<8&&cc>=0&&cc<8&&bd[rr][cc]&&bd[rr][cc].c===e&&bd[rr][cc].t==='k')return 1; }
  return 0;
}

/* game end detection & persistence */
function checkEnd() {
  let all=[];
  for(let r=0;r<8;r++)for(let c=0;c<8;c++)if(b[r][c]&&b[r][c].c===turn)all.push(...getLegal(r,c));
  if(!all.length) over = inCheck(turn) ? ((turn==='w'?'Black':'White')+' wins!') : 'Stalemate - Draw';
}

function newGame() { b=Array(8).fill().map(()=>Array(8).fill(null)); turn='w'; sel=null; moves=[]; over=false; last=null; castle={wk:1,wq:1,bk:1,bq:1}; ep=null; init(); saveGame(); engineResetPosition(); }
function flip() { flipped=!flipped; draw(); }

function saveGame() {
  try { const data = {b,turn,castle,ep,last,over,flipped}; localStorage.setItem('chess_save', JSON.stringify(data)); } catch(e){}
}

function loadGame() {
  try {
    const saved = localStorage.getItem('chess_save');
    if(saved) {
      const data = JSON.parse(saved);
      b = data.b || b;
      turn = data.turn || turn;
      castle = data.castle || castle;
      ep = data.ep || ep;
      last = data.last || last;
      over = data.over || over;
      flipped = data.flipped || flipped;
    } else {
      init(false);
    }
  } catch(e) { init(false); }
}

/* init on load */
loadGame();
draw();

/* -----------------------
   Engine integration (Stockfish WASM via worker)
   - Works on static hosting (GitHub Pages) when you use the worker .js from CDN.
   - We use UCI commands: 'position fen ...' + 'go movetime X'
   - Source for CDN: jsDelivr stockfish.wasm build. :contentReference[oaicite:2]{index=2}
   -----------------------*/

let engine = null;
let engineOn = false;
let engineColor = 'b'; // alap: gép játsszon feketén
let engineThinking = false;

function toggleEngine() {
  engineOn = !engineOn;
  document.getElementById('engineInfo').textContent = engineOn ? `Engine: on (${engineColor==='w'?'White':'Black'})` : 'Engine: off';
  document.getElementById('vsEngineBtn').textContent = engineOn ? 'Stop Engine' : 'Play vs Engine';
  if(engineOn) startEngine();
  else stopEngine();
  // ha most az engine következik, indítsuk el a lépést
  if(engineOn && turn === engineColor) engineMakeMove();
}

function startEngine() {
  if(engine) engine.terminate();
  try {
    engine = new Worker(STOCKFISH_WORKER_URL);
  } catch(e) {
    // fallback: próbáljuk sima stockfish.js (nem worker) betöltést (ritkábban szükséges)
    alert('Nem sikerült a Stockfish worker indítása a CDN-ről. Ellenőrizd a kapcsolatot.');
    engine = null; return;
  }
  engine.onmessage = onEngineMessage;
  sendToEngine('uci');
  sendToEngine('isready');
  sendToEngine('ucinewgame');
  engineResetPosition();
}

function stopEngine() {
  if(engine) { engine.terminate(); engine=null; }
  engineThinking = false;
}

function engineResetPosition() {
  if(!engine) return;
  const fen = boardToFEN();
  sendToEngine(`position fen ${fen}`);
}

/* board -> FEN (kell a motornak) */
function boardToFEN() {
  // b[0] = rank 8, b[7] = rank 1
  let parts = [];
  for(let r=0;r<8;r++) {
    let empty=0, rankStr='';
    for(let c=0;c<8;c++){
      const p = b[r][c];
      if(!p){ empty++; }
      else {
        if(empty>0){ rankStr += empty; empty=0; }
        const ch = p.t;
        rankStr += p.c==='w' ? ch.toUpperCase() : ch.toLowerCase();
      }
    }
    if(empty>0) rankStr += empty;
    parts.push(rankStr);
  }
  const boardFen = parts.join('/');
  const active = (turn==='w') ? 'w' : 'b';
  let cast = '';
  if(castle.wk) cast += 'K';
  if(castle.wq) cast += 'Q';
  if(castle.bk) cast += 'k';
  if(castle.bq) cast += 'q';
  if(cast === '') cast = '-';
  let epSq = '-';
  if(ep) {
    // ep is {r,c} with 0..7 coords; convert to algebraic
    epSq = idxToAlgebraic(ep.r, ep.c);
  }
  const halfmove = 0;
  const fullmove = 1;
  return `${boardFen} ${active} ${cast} ${epSq} ${halfmove} ${fullmove}`;
}

function idxToAlgebraic(r,c){
  // r:0..7 -> rank 8..1 ; c:0..7 -> files a..h
  return String.fromCharCode(97 + c) + (8 - r);
}

/* send/receive to engine */
function sendToEngine(cmd) {
  if(!engine) return;
  engine.postMessage(cmd);
  //console.log('>>',cmd);
}

function onEngineMessage(e) {
  const line = e.data ? e.data.toString() : '';
  //console.log('<<',line);
  if(line.startsWith('bestmove')) {
    engineThinking = false;
    const tokens = line.split(' ');
    if(tokens[1] && tokens[1] !== '(none)') {
      const uci = tokens[1].trim();
      applyUciMove(uci);
    }
  }
  // lehet debug: info üzeneteket is feldolgozni ha kell
}

/* Indítjuk a motort, hogy válasszon lépést */
function engineMakeMove() {
  if(!engine || engineThinking) return;
  engineResetPosition();
  engineThinking = true;
  // egyszerű: 200 ms (movetime) — növeld, ha erősebb játékost akarsz
  sendToEngine('go movetime 200');
}

/* Alkalmazzunk UCI move-ot (pl. e2e4 vagy e7e8q) */
function applyUciMove(uci) {
  if(!uci || uci.length < 4) return;
  const fromFile = uci[0], fromRank = uci[1], toFile = uci[2], toRank = uci[3];
  const fc = fromFile.charCodeAt(0) - 97;
  const fr = 8 - parseInt(fromRank);
  const tc = toFile.charCodeAt(0) - 97;
  const tr = 8 - parseInt(toRank);
  const promotion = (uci.length === 5) ? uci[4] : null;

  // detektáljuk en passant és sáncolás (king 2 mező)
  const movingPiece = b[fr][fc];
  if(!movingPiece) return;
  const m = {fr,fc,tr,tc};
  if(promotion) m.pr = promotion; // 'q','r','b','n'

  // en passant: ha a mozgatott gyalog célmező üres, de oszlopváltozás volt
  if(movingPiece.t==='p' && fc!==tc && !b[tr][tc]) m.enp = 1;

  // castling: király két mezőt lép
  if(movingPiece.t==='k' && Math.abs(tc - fc) === 2) {
    m.cas = (tc>fc) ? 'K' : 'Q';
  }

  applyMove(m);
}

/* simple engine control helpers */
function setEngineColor(col) { engineColor = col==='w'?'w':'b'; document.getElementById('engineInfo').textContent = engineOn ? `Engine: on (${engineColor==='w'?'White':'Black'})` : 'Engine: off'; }

/* Expose setEngineColor from console if you want: setEngineColor('w') to play black */
window.setEngineColor = setEngineColor;

/* If page loads and engine is on and it's engine's turn, make move */
window.addEventListener('load', ()=> {
  // nothing automatic on load
});
</script>
</body>
</html>
